<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>ReflectionsAndShadows - Samples</title>
    <script src="../../dist/l5.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<canvas id="ctx" width="640" height="480"></canvas>
<script>
    "use strict";

    function ReflectionsAndShadows() {
        L5.Application3.call(this, 'test1', 640, 480, [0.5, 0, 1, 1], 'ctx');

        this.textColor = "#fff";
        this.updateTime = 0;
        this.sceneCuller = null;
        this.scene = null;
        this.floor = null;
        this.wall = null;
        this.psEffect = null;
        this.prEffect = null;

        this.cube = null;
        this.cubeCuller = null;

        this.cubeAngle = 0;
    }
    L5.extendFix(ReflectionsAndShadows, L5.Application3);

    ReflectionsAndShadows.prototype.onInitialize = function () {
        if (!L5.Application3.prototype.onInitialize.call(this)) {
            return false;
        }

        // Set up the camera.
        this.camera.setPerspective(60.0, this.getAspectRatio(), 0.1, 2000);
        this.camera.lookAt(L5.Point.ORIGIN, L5.Point.ORIGIN, L5.Vector.UNIT_Y);
        var pos = new L5.Point(0, 1, -10);
        this.camera.setPosition(pos);

        this.effect = new L5.Texture2DEffect(
                L5.Shader.SF_LINEAR_LINEAR,
                L5.Shader.SC_REPEAT,
                L5.Shader.SC_REPEAT);

        // 禁用背面剔除
        this.renderer.overrideCullState.enabled = false;

        this.createScene();

        // Initial update of objects.
        this.scene.update();

        // Initial culling of scene,
        this.sceneCuller = new L5.Culler(this.camera);
        this.sceneCuller.computeVisibleSet(this.scene);
        this.cubeCuller = new L5.Culler(this.camera);
        this.cubeCuller.computeVisibleSet(this.cube);
        //

        this.initializeCameraMotion(0.1, 0.05);
        this.initializeObjectMotion(this.scene);
        return true;
    };
    ReflectionsAndShadows.prototype.onIdle = function () {
        this.measureTime();
        this.cubeAngle += 1;
        var angle = this.cubeAngle * Math.PI / 180;
        this.cube.localTransform
                .setRotate(L5.Matrix.makeRotateX(angle))
                .setTranslate(new L5.Point(Math.sin(angle) * 3, 2, Math.cos(angle) * 3));


        if (this.moveCamera()) {
            this.scene.update(this.applicationTime);
            this.sceneCuller.computeVisibleSet(this.scene);
            this.cubeCuller.computeVisibleSet(this.cube);
        }
        if (this.moveObject()) {
            this.scene.update(this.applicationTime);
            this.sceneCuller.computeVisibleSet(this.scene);
            this.cubeCuller.computeVisibleSet(this.cube);
        }
        this.camera.debug();

        // Draw the scene.
        if (this.renderer.preDraw()) {
            this.renderer.clearBuffers();
            this.renderer.drawVisibleSet(this.sceneCuller.visibleSet);
            this.renderer.drawVisibleSet(this.cubeCuller.visibleSet, this.psEffect);
            this.renderer.drawVisibleSet(this.cubeCuller.visibleSet, this.prEffect);

            this.drawFrameRate();
            this.renderer.postDraw();
        }
        this.updateFrameCount();
    };

    ReflectionsAndShadows.prototype.createScene = function () {
        this.scene = new L5.Node();

        // 创建场景光源
        var l = new L5.Light(L5.Light.LT_DIRECTIONAL);
        l.ambient.set([0.2, 0.2, 0.2, 1]);
        l.diffuse.set([0.5, 0.5, 0.5, 1]);
        l.specular.set([0.8, 0.8, 0.8, 1]);
        var dir = new L5.Vector(0, -100, -10);
        dir.normalize();
        l.direction = dir;

        this.light = l;

        this.createCube();
        this.createPoints();
        this.createFloor();
        this.createWall();
        this.createPlanarShadow();
        this.createPlanarReflection();
    };


    ReflectionsAndShadows.prototype.createFloor = function () {
        const format = L5.VertexFormat.create(2,
                L5.VertexFormat.AU_POSITION, L5.VertexFormat.AT_FLOAT3, 0,
                L5.VertexFormat.AU_TEXCOORD, L5.VertexFormat.AT_FLOAT2, 0);
        const stride = format.stride;
        const usage = format.usage;

        // Create the floor mesh.
        var vbuffer = new L5.VertexBuffer(4, stride);
        var vba = new L5.VertexBufferAccessor(format, vbuffer);

        var xValue = 256;
        var zValue = 128;
        const uv = 16;
        vba.setPosition(0, [-xValue, 0, +zValue]);
        vba.setPosition(1, [+xValue, 0, +zValue]);
        vba.setPosition(2, [+xValue, 0, -zValue]);
        vba.setPosition(3, [-xValue, 0, -zValue]);
        vba.setTCoord(0, 0, [0, 0]);
        vba.setTCoord(0, 1, [uv, 0]);
        vba.setTCoord(0, 2, [uv, uv]);
        vba.setTCoord(0, 3, [0, uv]);

        var ibuffer = new L5.IndexBuffer(6, 4, usage);
        var indices = new Uint32Array(ibuffer.getData().buffer);
        indices[0] = 0;
        indices[1] = 1;
        indices[2] = 2;
        indices[3] = 0;
        indices[4] = 2;
        indices[5] = 3;
        this.floor = new L5.TriMesh(format, vbuffer, ibuffer);

        var $this = this;
        ++this.loadWait;
        L5.Texture2D.loadWMTF("Stone.wmtf").then(function (texture) {
            $this.floor.effect = $this.effect.createInstance(texture);
            --$this.loadWait;
        });

        this.scene.attachChild(this.floor);
    };

    ReflectionsAndShadows.prototype.createCube = function () {
        var format = L5.VertexFormat.create(2,
                L5.VertexFormat.AU_POSITION, L5.VertexFormat.AT_FLOAT3, 0,
                L5.VertexFormat.AU_NORMAL, L5.VertexFormat.AT_FLOAT3, 0);

        var stdMesh = new L5.StandardMesh(format);
        // this.cube = stdMesh.rectangle(2,2,2,2);
        // this.cube = stdMesh.hexahedron();
        // this.cube = stdMesh.icosahedron();
        this.cube = stdMesh.sphere(32, 32, 1);
        // this.cube = stdMesh.box(1,1,1);
        // this.cube = stdMesh.torus(28, 28, 1.5, 0.25);
        // this.cube = stdMesh.cylinder(4, 32, 1, 0.1, false);
        this.cube.culling = L5.Spatial.CULLING_NEVER;

        var m = new L5.Material();
        m.ambient.set([0.3, 0.3, 0.3, 1]);
        m.diffuse.set([0.3, 0.3, 0.3, 1]);
        m.specular.set([0.674098551273346, 0.5075565576553345, 0.5366353392601013, 128]);
        m.emissive.set([0.674098551273346, 0.5075565576553345, 0.5366353392601013, 1]);


        //var instance = new L5.DefaultEffect().createInstance();
        // var instance = new L5.LightAmbEffect().createInstance(l, m);
        var instance = L5.LightDirPerFragEffect.createUniqueInstance(this.light, m);
        //var instance = L5.LightDirPerVerEffect.createUniqueInstance(l,m);
        this.cube.effect = instance;
        this.scene.attachChild(this.cube);
    };
    ReflectionsAndShadows.prototype.createWall = function () {
        var $this = this;
        const format = L5.VertexFormat.create(2,
                L5.VertexFormat.AU_POSITION, L5.VertexFormat.AT_FLOAT3, 0,
                L5.VertexFormat.AU_NORMAL, L5.VertexFormat.AT_FLOAT3, 0);

        // Create the wall mesh.
        const stdMesh = new L5.StandardMesh(format);

        this.wall = stdMesh.rectangle(2, 2, 10, 2);
        this.wall.localTransform.setRotate(L5.Matrix.makeRotateY(Math.PI));
        this.wall.localTransform.setTranslate(new L5.Point(0, 1, 10));

        var m = new L5.Material();
        m.ambient.set([0.2, 0.2, 0.2, 1]);
        m.diffuse.set([0.5, 0.5, 0.5, 1]);
        m.specular.set([0.6, 0.5, 0.2, 0.001]);

        var instance = L5.LightDirPerFragEffect.createUniqueInstance(this.light, m);
        this.wall.effect = instance;
        this.scene.attachChild(this.wall);
    };


    // 创建参考点
    ReflectionsAndShadows.prototype.createPoints = function () {
        var format = L5.VertexFormat.create(2,
                L5.VertexFormat.AU_POSITION, L5.VertexFormat.AT_FLOAT3, 0,
                L5.VertexFormat.AU_COLOR, L5.VertexFormat.AT_FLOAT3, 0);

        const stride = format.stride;
        const usage = format.usage;

        // Create the floor mesh.
        var vbuffer = new L5.VertexBuffer(4, stride);
        var vba = new L5.VertexBufferAccessor(format, vbuffer);

        vba.setPosition(0, [0, 0, 0]);   // 原点: 红色
        vba.setPosition(1, [1, 0, 0]);  // +x: 绿色
        vba.setPosition(2, [0, 1, 0]);  // +y: 蓝色
        vba.setPosition(3, [0, 0, 1]);  // +z: 黄色

        vba.setColor(0, 0, [1, 0, 0]);
        vba.setColor(0, 1, [0, 1, 0]);
        vba.setColor(0, 2, [0, 0, 1]);
        vba.setColor(0, 3, [1, 1, 0]);

        this.points = new L5.PolyPoint(format, vbuffer);
        this.points.effect = L5.VertexColor3Effect.createUniqueInstance();
        this.points.culling = L5.Spatial.CULLING_NEVER;
        this.scene.attachChild(this.points);
    };
    ReflectionsAndShadows.prototype.createPlanarShadow = function () {
        const flag = false;
        var projector;
        if (flag) {
            projector = new L5.Light(L5.Light.LT_POINT);
            projector.position = new L5.Point(0, 15, 0);
        } else {
            projector = new L5.Light(L5.Light.LT_DIRECTIONAL);
            var dir = new L5.Vector(0, -1, 0);
            dir.normalize();
            projector.direction = dir;
        }

        var projectorNode = new L5.LightNode(projector);
        this.scene.attachChild(projectorNode);

        this.psEffect = new L5.PlanarShadowEffect(1, this.cube);
        this.psEffect.setPlane(0, this.floor);
        this.psEffect.setProjector(0, projector);
        this.psEffect.setShadowColor(0, new Float32Array([0, 0, 0, 0.7]));
    };

    ReflectionsAndShadows.prototype.createPlanarReflection = function () {
        var projector = new L5.Light(L5.Light.LT_DIRECTIONAL);
        projector.direction = L5.Vector.UNIT_Z.negative();
        var projectorNode = new L5.LightNode(projector);
        this.scene.attachChild(projectorNode);

        this.prEffect = new L5.PlanarReflectionEffect(1);
        this.prEffect.setPlane(0, this.wall);
        this.prEffect.setReflectance(0, 0.2);
    };

    var ras = new ReflectionsAndShadows();
    ras.run();


</script>
</body>
</html>